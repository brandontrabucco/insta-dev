from insta.utils import (
    BrowserStatus
)

from insta.configs.agent_config import (
    BrowserAction
)

from insta.configs.browser_config import (
    FunctionCall
)

from typing import List
import re
import json


def get_function_calls(
    action_dict: dict
) -> List[FunctionCall]:
    
    function_calls = []

    target_element_id = action_dict.get(
        "target_element_id"
    )

    action_key = action_dict.get(
        "action_key"
    )

    action_kwargs = action_dict.get(
        "action_kwargs"
    )

    actions_with_target = [
        "click", "hover", "fill",
        "select_option", "set_checked"
    ]
    
    if target_element_id is not None \
            and action_key in actions_with_target:
        
        function_calls.append(
            FunctionCall(
                dotpath = "page.locator",
                args = "\"[backend_node_id='{}']\"".format(
                    target_element_id
                )
            )
        )
        
    if action_key == "click" and "x" in action_kwargs and "y" in action_kwargs:

        function_calls.append(
            FunctionCall(
                dotpath = "page.mouse.click",
                args = "{},{}".format(
                    action_kwargs.get("x", 0),
                    action_kwargs.get("y", 0)
                )
            )
        )
        
    elif action_key == "click" and target_element_id is not None:

        function_calls.append(
            FunctionCall(
                dotpath = "click",
                args = "{ force: true }"
            )
        )
        
    elif action_key == "hover" and target_element_id is not None:

        function_calls.append(
            FunctionCall(
                dotpath = "hover",
                args = ""
            )
        )

    elif action_key == "scroll":

        function_calls.append(
            FunctionCall(
                dotpath = "page.mouse.wheel",
                args = "{},{}".format(
                    action_kwargs.get("delta_x", 0),
                    action_kwargs.get("delta_y", 0)
                )
            )
        )

    elif action_key == "fill" and target_element_id is not None:

        function_calls.append(
            FunctionCall(
                dotpath = "fill",
                args = "'{}'".format(
                    action_kwargs.get("value")
                )
            )
        )

    elif action_key == "select_option" and target_element_id is not None:
        
        function_calls.append(
            FunctionCall(
                dotpath = "selectOption",
                args = "'{}'".format(
                    action_kwargs.get("label")
                )
            )
        )

    elif action_key == "set_checked" and target_element_id is not None:

        function_calls.append(
            FunctionCall(
                dotpath = "setChecked",
                args = "{}".format(
                    "true" if action_kwargs.get("checked", False) else "false"
                )
            )
        )

    elif action_key == "go_back":

        function_calls.append(
            FunctionCall(
                dotpath = "page.goBack",
                args = ""
            )
        )

    elif action_key == "go_forward":

        function_calls.append(
            FunctionCall(
                dotpath = "page.goForward",
                args = ""
            )
        )

    elif action_key == "goto":

        function_calls.append(
            FunctionCall(
                dotpath = "page.goto",
                args = "'{}'".format(
                    action_kwargs.get("url")
                )
            )
        )

    elif action_key == "stop":

        function_calls.append(
            FunctionCall(
                dotpath = "stop",
                args = "{}".format(
                    action_kwargs.get("answer")
                )
            )
        )

    return function_calls


AGENT_PATTERN = re.compile(
    r"```json\n(?P<json>.*)\n```",
    re.DOTALL
)

SYSTEM_PROMPT = """You are an agent that interacts with and navigates live webpages. Our goal is to complete an internet-based task by operating a virtual web browser."""

USER_PROMPT_TEMPLATE = """## Complete The Following Task

{instruction}

You are at {current_url} observing the viewport:

{observation}"""


class BaseAgentPrompt(object):
    """Implements a parser for converting text generated by an LLM into a
    sequence of function calls to the Playwright API, represented as a
    BrowserAction that contains FunctionCall objects.

    Attributes:

    system_prompt: str
        Depending on the kind of action representation, this system prompt
        instructs the LLM on how to generate actions in the corresponding format,
        such as JSON-based actions, JavaScript code, etc.

    user_prompt_template: str
        A template string that is used to generate a user prompt for the LLM,
        and had format keys for `observation` and `instruction`.

    """

    system_prompt = SYSTEM_PROMPT
    user_prompt_template = USER_PROMPT_TEMPLATE

    def parse_action(self, response: str) -> BrowserAction | BrowserStatus:
        """Parse an action string produced by an LLM, and return a
        BrowserAction object that contains a sequence of function calls
        to perform in a web browsing session.

        Arguments:

        response: str
            The response from an LLM that contains an action embedded in code,
            which will be parsed into a BrowserAction object.
        
        
        Returns:

        BrowserAction | PlaywrightStatus
            A BrowserAction object that contains a sequence of function
            calls to perform in a web browsing session, or a PlaywrightStatus
            object that indicates parsing the action failed.
        
        """
        
        match = AGENT_PATTERN.search(response)

        is_valid = (
            match is not None and 
            "json" in match.groupdict()
        )

        if not is_valid:
    
            raise ValueError(
                "Failed to parse action"
            )

        matched_response = match.group("json")

        response_dict = json.loads(
            matched_response
        )

        function_calls = get_function_calls(
            response_dict
        )

        if len(function_calls) == 0:
    
            raise ValueError(
                "Failed to parse action"
            )
        
        playwright_action = BrowserAction(
            function_calls = function_calls,
            response = response,
            matched_response = matched_response
        )

        return playwright_action
