from insta.utils import (
    BrowserStatus
)

from insta.configs.task_proposer_config import (
    BrowserTaskProposal
)

import re
import json


TASK_PATTERN = re.compile(
    r"```json\n(?P<json>.*)\n```",
    re.DOTALL
)

SYSTEM_PROMPT = """You are helping me assign tasks to a language model agent that interacts with and navigates live webpages."""

USER_PROMPT_TEMPLATE = """You are viewing the agent's trajectory during its operation:

{summary}

Based on the agent's trajectory, assign the next task."""


class BaseTaskProposerPrompt(object):
    """Implements a parser for converting text generated by an LLM into a
    task for an LLM agent to attempt to complete using a web browser,
    returns a BrowserJudgment instance parsed from the response.

    Attributes:

    system_prompt: str
        Depending on the task representation, this system prompt
        instructs the LLM on how to generate tasks in the corresponding format,
        such as JSON-based tasks, YAML format, etc.

    user_prompt_template: str
        A template string that is used to generate a user prompt for the LLM,
        and has format keys for `annotations` which represents
        previous task runs and judgments produced by the LLM judge.

    """

    system_prompt = SYSTEM_PROMPT
    user_prompt_template = USER_PROMPT_TEMPLATE

    def parse_task(self, response: str) -> BrowserTaskProposal | BrowserStatus:
        """Parse a task proposal string produced by an LLM, and return a
        BrowserTaskProposal object that contains the proposed task,
        and additional metadata about the task feasibility, and difficulty.

        Arguments:

        response: str
            The response from an LLM that contains a task proposal in a code block,
            which will be parsed into a BrowserTaskProposal object.
        
        Returns:

        BrowserTaskProposal | PlaywrightStatus
            The parsed task proposal, or a BrowserStatus object that
            represents a failed parsing attempt.
        
        """
        
        match = TASK_PATTERN.search(response)

        has_required_field = (
            match is not None and 
            "json" in match.groupdict()
        )

        if not has_required_field:
    
            raise ValueError(
                "Failed to parse task"
            )

        matched_response = match.group("json")
        response_dict = json.loads(
            matched_response
        )
        
        has_required_keys = (
            "proposed_task" in response_dict and
            "steps" in response_dict and
            "criteria" in response_dict
        )

        if not has_required_keys:
    
            raise ValueError(
                "Failed to parse task"
            )
        
        proposed_task = response_dict["proposed_task"]
        steps = response_dict["steps"]
        criteria = response_dict["criteria"]
        
        keys_right_type = (
            (isinstance(proposed_task, str) and (len(proposed_task) > 0)) and
            (isinstance(steps, list) and (len(steps) > 0)) and
            (isinstance(criteria, list) and (len(criteria) > 0))
        )

        if not keys_right_type:
    
            raise ValueError(
                "Failed to parse task"
            )
        
        task_dict = {
            "proposed_task": str(proposed_task),
            "steps": list(steps),
            "criteria": list(criteria),
        }
        
        browser_task = BrowserTaskProposal(
            **task_dict,
            response = response,
            matched_response = matched_response
        )

        return browser_task
